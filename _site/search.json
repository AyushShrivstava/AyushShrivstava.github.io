[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Ayush Shrivastava",
    "section": "",
    "text": "I am a first-year PhD student in Computer Science and Engineering at IIT Gandhinagar, working at the intersection of machine learning, sustainability, and health sensing. I am an active member of the Sustainability Lab, led by Prof. Nipun Batra, and the Smash Lab, led by Prof. Mayank Goel.\nI hold a master’s degree in Computer Science and Engineering from IIT Gandhinagar and a bachelor’s degree in Electronics and Telecommunications from Jabalpur Engineering College. My research focuses on applying machine learning to develop innovative solutions in sustainability and health sensing. I am passionate about solving challenging problems using machine learning to create meaningful impact."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "publication.html",
    "href": "publication.html",
    "title": "Publication",
    "section": "",
    "text": "Under review will be added soon."
  },
  {
    "objectID": "teaching.html",
    "href": "teaching.html",
    "title": "Teaching",
    "section": "",
    "text": "2024\n\n\nSpring and Fall : Machine Learning,\n\n\nProfessor Incharge: Nipun Batra  Organised and evaluated quizzes, assignments, took vivas for a classroom of 300 students, while also playing a pivotal role in supporting classroom logistics.\n\n\n2023\n\n\nFall : Computer Systems\n\n\nProfessor Incharge: Abhishek Bichhawat, Sameer G Kulkarni  Graded assignments and assisted the professor run a class of 40 students smoothly.\n\n\nSummer : World of Engineering\n\n\nProfessor Incharge: Udit Bhatia  Mentored a group of 30 students in the identification, conceptualization, and modeling of a prototype to address a real-world problem, fostering their problem-solving abilities and teamwork skills.\n\n\nSpring : Probability, Statistics and Data Visualization\n\n\nProfessor Incharge: Shanmuganathan Raman  Successfully guided over 30 students in Python libraries, including Numpy, Pandas, Matplotlib, Scipy, and Scikit-learn, enhancing their data visualization skills.\n\n\n2022\n\n\nWinter : Introduction to Computing\n\n\nProfessor Incharge: Nipun Batra, Balagopal Komarath  Led a Python lab for 30 students, teaching them essential Python concepts, and helped manage logistics, invigilation, and quiz evaluation for a class of 300 students."
  },
  {
    "objectID": "index.html#my-journey-so-far",
    "href": "index.html#my-journey-so-far",
    "title": "Ayush Shrivastava",
    "section": "My Journey So Far",
    "text": "My Journey So Far\n\n\n\n\n\n\n31 Aug 2024\n\n\nJoined Sustainability Lab and Smash Lab as a PhD student\n\n\n\n\n15 Jul 2024\n\n\nJoined IIT Gandhinagar as PhD student under the supervision of Prof Nipun Batra and Prof Mayank Goel\n\n\n\n\n8-11 Jul 2024\n\n\nAttended 7th ACM SIGCAS/SIGCHI Conference of Computing and Sustainable Societies ACM COMPASS 2024\n\n\n\n\n29 Jun 2024\n\n\nConvocation! Got Masters degree from IIT Gandhinagar\n\n\n\n\n14 Jun 2024\n\n\nGot brutally attacked but successfully defended my Masters Thesis\n\n\n\n\n\n2 Feb 2024\n\n\nSubmitted the first draft of our work to IMWUT ’24, marking my first research paper submission ever.\n\n\n\n\n10 Oct 2023\n\n\nGot Placed in Atlas Copco as Software Developer\n\n\n\n\n\n01 Jan 2023\n\n\nJoined Sustainability Lab as a masters student at IIT Gandhinagar\n\n\n\n\n18 jul 2022\n\n\nJoined IIT Gandhinagar for M.Tech in Computer Science and Engineering\n\n\n\n\n15 Mar 2022\n\n\nAttained 98.16 percentile in Graduate Aptitude Test in Engineering 2022 (GATE’22)\n\n\n\n\n17 jun 2019\n\n\nJoined IBM India as an Application Developer, Enterprise Resource Planning (ERP)\n\n\n\n\n15 May 2019\n\n\nCompleted B.E in Electronics and Telecommunication from Jabalpur Engineering College, Jabalpur"
  },
  {
    "objectID": "posts.html",
    "href": "posts.html",
    "title": "My Blog",
    "section": "",
    "text": "Canny Edge Detector\n\n\n\nComputer Vision\n\n\n\n\n\n\n\nAyush Shrivastava\n\n\nDec 6, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSetting up Conda Environment for ML Projects\n\n\n\nHelpful Tips\n\n\n\n\n\n\n\nAyush Shrivastava\n\n\nJun 16, 2024\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2024-06-16-CondaTips/2024-06-16-Post1.html",
    "href": "posts/2024-06-16-CondaTips/2024-06-16-Post1.html",
    "title": "Setting up Conda Environment for ML Projects",
    "section": "",
    "text": "This blogpost is written for myself as I keep forgetting the steps to set up a conda environment for my ML projects."
  },
  {
    "objectID": "posts/2024-06-16-CondaTips/2024-06-16-Post1.html#install-conda",
    "href": "posts/2024-06-16-CondaTips/2024-06-16-Post1.html#install-conda",
    "title": "Setting up Conda Environment for ML Projects",
    "section": "Install Conda",
    "text": "Install Conda\nThese four commands quickly and quietly install the latest 64-bit version of the installer and then clean up after themselves. To install a different version or architecture of Miniconda for Linux, change the name of the .sh installer in the wget command.\nVisit the Miniconda website to find the latest version of Miniconda for Linux.\nmkdir -p ~/miniconda3\nwget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh -O ~/miniconda3/miniconda.sh\nbash ~/miniconda3/miniconda.sh -b -u -p ~/miniconda3\nrm -rf ~/miniconda3/miniconda.sh\nAfter installing, initialize your newly-installed Miniconda. The following commands initialize for bash and zsh shells:\n~/miniconda3/bin/conda init bash\n~/miniconda3/bin/conda init zsh\nyou can run conda -V to check if conda is installed correctly."
  },
  {
    "objectID": "posts/2024-06-16-CondaTips/2024-06-16-Post1.html#creating-conda-environment",
    "href": "posts/2024-06-16-CondaTips/2024-06-16-Post1.html#creating-conda-environment",
    "title": "Setting up Conda Environment for ML Projects",
    "section": "Creating Conda Environment",
    "text": "Creating Conda Environment\nThe below command will create the conda environment with the name EnvName and python version 3.9.\nconda create --name EnvName python=3.9 jupyter\nTo activate the environment, run the below command:\nconda activate EnvName"
  },
  {
    "objectID": "posts/2024-06-16-CondaTips/2024-06-16-Post1.html#installing-pytorch",
    "href": "posts/2024-06-16-CondaTips/2024-06-16-Post1.html#installing-pytorch",
    "title": "Setting up Conda Environment for ML Projects",
    "section": "Installing Pytorch",
    "text": "Installing Pytorch\nVisit the Pytorch website to find the latest version of Pytorch. You can choose your system configuration and get the command to install Pytorch.\n\nconda install pytorch torchvision torchaudio pytorch-cuda=11.8 -c pytorch -c nvidia\ncheck if everything is installed correctly by running the below command:\npython -c \"import torch; print(torch.__version__)\"\nInstalling other libraries and packages."
  },
  {
    "objectID": "posts/CondaTips/CondaPost.html",
    "href": "posts/CondaTips/CondaPost.html",
    "title": "Setting up Conda Environment for ML Projects",
    "section": "",
    "text": "This blogpost is written for myself as I keep forgetting the steps to set up a conda environment for my ML projects."
  },
  {
    "objectID": "posts/CondaTips/CondaPost.html#install-conda",
    "href": "posts/CondaTips/CondaPost.html#install-conda",
    "title": "Setting up Conda Environment for ML Projects",
    "section": "Install Conda",
    "text": "Install Conda\nThese four commands quickly and quietly install the latest 64-bit version of the installer and then clean up after themselves. To install a different version or architecture of Miniconda for Linux, change the name of the .sh installer in the wget command.\nVisit the Miniconda website to find the latest version of Miniconda for Linux.\nmkdir -p ~/miniconda3\nwget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh -O ~/miniconda3/miniconda.sh\nbash ~/miniconda3/miniconda.sh -b -u -p ~/miniconda3\nrm -rf ~/miniconda3/miniconda.sh\nAfter installing, initialize your newly-installed Miniconda. The following commands initialize for bash and zsh shells:\n~/miniconda3/bin/conda init bash\n~/miniconda3/bin/conda init zsh\nyou can run conda -V to check if conda is installed correctly."
  },
  {
    "objectID": "posts/CondaTips/CondaPost.html#creating-conda-environment",
    "href": "posts/CondaTips/CondaPost.html#creating-conda-environment",
    "title": "Setting up Conda Environment for ML Projects",
    "section": "Creating Conda Environment",
    "text": "Creating Conda Environment\nThe below command will create the conda environment with the name EnvName and python version 3.9.\nconda create --name EnvName python=3.9 jupyter\nTo activate the environment, run the below command:\nconda activate EnvName"
  },
  {
    "objectID": "posts/CondaTips/CondaPost.html#installing-pytorch",
    "href": "posts/CondaTips/CondaPost.html#installing-pytorch",
    "title": "Setting up Conda Environment for ML Projects",
    "section": "Installing Pytorch",
    "text": "Installing Pytorch\nVisit the Pytorch website to find the latest version of Pytorch. You can choose your system configuration and get the command to install Pytorch.\n\nconda install pytorch torchvision torchaudio pytorch-cuda=11.8 -c pytorch -c nvidia\ncheck if everything is installed correctly by running the below command:\npython -c \"import torch; print(torch.__version__)\"\nInstalling other libraries and packages."
  },
  {
    "objectID": "posts/2024/CondaPost.html",
    "href": "posts/2024/CondaPost.html",
    "title": "Setting up Conda Environment for ML Projects",
    "section": "",
    "text": "This blogpost is written for myself as I keep forgetting the steps to set up a conda environment for my ML projects."
  },
  {
    "objectID": "posts/2024/CondaPost.html#install-conda",
    "href": "posts/2024/CondaPost.html#install-conda",
    "title": "Setting up Conda Environment for ML Projects",
    "section": "Install Conda",
    "text": "Install Conda\nThese four commands quickly and quietly install the latest 64-bit version of the installer and then clean up after themselves. To install a different version or architecture of Miniconda for Linux, change the name of the .sh installer in the wget command.\nVisit the Miniconda website to find the latest version of Miniconda for Linux.\nmkdir -p ~/miniconda3\nwget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh -O ~/miniconda3/miniconda.sh\nbash ~/miniconda3/miniconda.sh -b -u -p ~/miniconda3\nrm -rf ~/miniconda3/miniconda.sh\nAfter installing, initialize your newly-installed Miniconda. The following commands initialize for bash and zsh shells:\n~/miniconda3/bin/conda init bash\n~/miniconda3/bin/conda init zsh\nyou can run conda -V to check if conda is installed correctly."
  },
  {
    "objectID": "posts/2024/CondaPost.html#creating-conda-environment",
    "href": "posts/2024/CondaPost.html#creating-conda-environment",
    "title": "Setting up Conda Environment for ML Projects",
    "section": "Creating Conda Environment",
    "text": "Creating Conda Environment\nThe below command will create the conda environment with the name EnvName and python version 3.9.\nconda create --name EnvName python=3.9 jupyter\nTo activate the environment, run the below command:\nconda activate EnvName"
  },
  {
    "objectID": "posts/2024/CondaPost.html#installing-pytorch",
    "href": "posts/2024/CondaPost.html#installing-pytorch",
    "title": "Setting up Conda Environment for ML Projects",
    "section": "Installing Pytorch",
    "text": "Installing Pytorch\nVisit the Pytorch website to find the latest version of Pytorch. You can choose your system configuration and get the command to install Pytorch.\n\nconda install pytorch torchvision torchaudio pytorch-cuda=11.8 -c pytorch -c nvidia\ncheck if everything is installed correctly by running the below command:\npython -c \"import torch; print(torch.__version__)\"\nInstalling other libraries and packages."
  },
  {
    "objectID": "gallery.html",
    "href": "gallery.html",
    "title": "Gallery",
    "section": "",
    "text": "Welcome to my gallery! Here you’ll find a collection of images from my life, including memorable moments and photos I’ve taken. I’ll continue to add more images as I capture new experiences and milestones along my journey.\n\n\n\n\n&lt;img src=\"images/gallery/compass24.jpg\" alt=\"Outside IIIT Delhi main Academics Building\"&gt;\n&lt;p&gt;Attending ACM Compass with the Lab&lt;/p&gt;\n\n\n&lt;img src=\"images/gallery/ACM_Compass1.jpg\" alt=\"ACM Compass inside Conference Hall\"&gt;\n&lt;p&gt;ACM Compass - infront of conference hall&lt;/p&gt;\n\n\n&lt;img src=\"images/gallery/IIITD1.jpg\" alt=\"Near IIITD gate\"&gt;\n&lt;p&gt;Inside IIIT Delhi Campus&lt;/p&gt;\n\n\n\n\n\n\n\n\n&lt;img src=\"images/gallery/convocation2.jpg\" alt=\"Awarded the MTech\"&gt;\n&lt;p&gt;Awarded the MTech in Computer Science and Engineering at IITGN convocation June 2024&lt;/p&gt;\n\n\n&lt;img src=\"images/gallery/convocation.jpg\" alt=\"Outside IITGN Convocation Hall 2024\"&gt;\n&lt;p&gt;Outside IITGN Convocation Hall June 2024&lt;/p&gt;\n\n\n&lt;img src=\"images/gallery/convocation3.jpg\" alt=\"Outside IITGN Convocation Hall 2024\"&gt;\n&lt;p&gt;Outside IITGN Convocation Hall with my family&lt;/p&gt;\n\n\n\n\n\n\n\n\n&lt;img src=\"images/gallery/MtechThesisDefense.jpg\" alt=\"2024 June Mtech defense\"&gt;\n&lt;p&gt;Suraj and I celebrating the successful defense of our MTech thesis&lt;/p&gt;\n\n\n&lt;img src=\"images/gallery/MtechThesisDefense3.jpg\" alt=\"2024 June Mtech defense\"&gt;\n&lt;p&gt;Celebrating the successful defense of our MTech thesis&lt;/p&gt;"
  },
  {
    "objectID": "gallery.html#acm-compass-2024-iiit_delhi",
    "href": "gallery.html#acm-compass-2024-iiit_delhi",
    "title": "Gallery",
    "section": "",
    "text": "&lt;img src=\"images/gallery/compass24.jpg\" alt=\"Outside IIIT Delhi main Academics Building\"&gt;\n&lt;p&gt;Attending ACM Compass with the Lab&lt;/p&gt;\n\n\n&lt;img src=\"images/gallery/ACM_Compass1.jpg\" alt=\"ACM Compass inside Conference Hall\"&gt;\n&lt;p&gt;ACM Compass - infront of conference hall&lt;/p&gt;\n\n\n&lt;img src=\"images/gallery/IIITD1.jpg\" alt=\"Near IIITD gate\"&gt;\n&lt;p&gt;Inside IIIT Delhi Campus&lt;/p&gt;"
  },
  {
    "objectID": "gallery.html#mtech-convocation-2024",
    "href": "gallery.html#mtech-convocation-2024",
    "title": "Gallery",
    "section": "",
    "text": "&lt;img src=\"images/gallery/convocation2.jpg\" alt=\"Awarded the MTech\"&gt;\n&lt;p&gt;Awarded the MTech in Computer Science and Engineering at IITGN convocation June 2024&lt;/p&gt;\n\n\n&lt;img src=\"images/gallery/convocation.jpg\" alt=\"Outside IITGN Convocation Hall 2024\"&gt;\n&lt;p&gt;Outside IITGN Convocation Hall June 2024&lt;/p&gt;\n\n\n&lt;img src=\"images/gallery/convocation3.jpg\" alt=\"Outside IITGN Convocation Hall 2024\"&gt;\n&lt;p&gt;Outside IITGN Convocation Hall with my family&lt;/p&gt;"
  },
  {
    "objectID": "gallery.html#mtech-thesis-defense-2024",
    "href": "gallery.html#mtech-thesis-defense-2024",
    "title": "Gallery",
    "section": "",
    "text": "&lt;img src=\"images/gallery/MtechThesisDefense.jpg\" alt=\"2024 June Mtech defense\"&gt;\n&lt;p&gt;Suraj and I celebrating the successful defense of our MTech thesis&lt;/p&gt;\n\n\n&lt;img src=\"images/gallery/MtechThesisDefense3.jpg\" alt=\"2024 June Mtech defense\"&gt;\n&lt;p&gt;Celebrating the successful defense of our MTech thesis&lt;/p&gt;"
  },
  {
    "objectID": "posts/2024/Canny_Edge.html",
    "href": "posts/2024/Canny_Edge.html",
    "title": "Canny Edge Detector",
    "section": "",
    "text": "Canny Edge Detector\nThe Canny Edge detector is named after its inventor, John F. Canny. It is among the most popular edge detection algorithms due to its simplicity and effectiveness. The algorithm uses gradient information to detect edges. It follow the following steps:\n\n1. Smoothing or Noise Reduction :\nThe algorithm uses a Gaussian filter to smooth the image and reduce noise. This is done to prevent the algorithm from detecting false edges due to noise. It also smoothens the image to reduce the abrupt changes in pixel values. These abrupt changes may end up being detected as edges.\n\\[I'(x,y) = G(x,y) * I(x,y)\\]\nwhere \\(I(x,y)\\) is the input image, \\(G(x,y)\\) is the Gaussian filter and \\(I'(x,y)\\) is the smoothed image. ’*’ represents convolution operation between the image and the filter. Reading the image and convert it to grayscale. Image is converted to grayscale because the edge detection is done on the intensity values of the image. The color information is not required for edge detection.\n\n# Importing libraries \nimport numpy as np\nimport matplotlib.pyplot as plt\nimport cv2 as cv\n\n# Read the image\nimage = cv.imread('flower.jpeg')\n\nplt.figure(figsize=(12, 4))\n# Convert the image to RGB (OpenCV loads it into BGR by default)\nplt.subplot(1, 3, 1)\nplt.imshow(cv.cvtColor(image, cv.COLOR_BGR2RGB))\nplt.axis('off')\nplt.title('Original Image')\n\n# Convert the image to grayscale\ngray_image = cv.cvtColor(image, cv.COLOR_BGR2GRAY)\nplt.subplot(1, 3, 2)\nplt.imshow(gray_image, cmap='gray')\nplt.axis('off')\nplt.title('Grayscaled Image')\n\n# Apply Gaussian Blur\nblurred_image = cv.GaussianBlur(gray_image, (3, 3), 0)\nplt.subplot(1, 3, 3)\nplt.imshow(blurred_image, cmap='gray')\nplt.axis('off')\nplt.title('Gaussian Blurred Image')\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n2. Gradient Calculation :\nThe algorithm then calculates the gradient of the image. The gradient is calculated using the Sobel operator. The Sobel operator is a discrete differentiation operator. It computes an approximation of gradient of the image. The operator uses two 3x3 kernels which are convolved with the original image to calculate approximations of the derivatives - one for horizontal changes, and one for vertical. \\(G_x\\) and \\(G_y\\) are the horizontal and vertical Sobel operators respectively.\n\\[G_x = \\begin{bmatrix} -1 & 0 & 1 \\\\ -2 & 0 & 2 \\\\ -1 & 0 & 1 \\end{bmatrix}\\] \\[G_y = \\begin{bmatrix} -1 & -2 & -1 \\\\ 0 & 0 & 0 \\\\ 1 & 2 & 1 \\end{bmatrix}\\]\n\\[I_y = I' * G_y\\] \\[I_x = I' * G_x\\]\nwhere \\(I_x\\) and \\(I_y\\) are the horizontal and vertical gradients respectively.\nNow the combined gradient magnitude could be calculated using two methods. * Using L1 Norm:\n\\[Magnitude = |I_x| + |I_y|\\]\n\nUsing L2 Norm:\n\n\\[Magnitude =  \\sqrt{I_x^2 + I_y^2}\\]\n\\[Direction = \\arctan(\\frac{I_y}{I_x})\\]\nMagnitude signifies the strength of the edge. The direction is the angle of the edge. The direction is rounded to one of four angles representing vertical, horizontal and two diagonals. The angles are 0, 45, 90 and 135 degrees. We are assuming the edges are in one of these four directions.\n\n# Compute the gradients by applying Sobel operator\nI_x = cv.Sobel(blurred_image, cv.CV_64F, 1, 0, ksize=3)\nI_y = cv.Sobel(blurred_image, cv.CV_64F, 0, 1, ksize=3)\n\n# Compute the magnitude of the gradients\nmagnitude = np.sqrt(I_x**2 + I_y**2)\n\n# Compute the magnitude of the gradients using the L1 norm\n# magnitude = np.abs(I_x) + np.abs(I_y)\n\ndirection = np.arctan2(I_y, I_x)\n\nplt.figure(figsize=(9, 7))\n\nplt.subplot(2, 2, 1)\nplt.imshow(cv.convertScaleAbs(I_x), cmap='gray')\nplt.axis('off')\nplt.title('Gradient in X direction')\ncbar = plt.colorbar()\ncbar.set_label('Gradient Intensity')\n\nplt.subplot(2, 2, 2)\nplt.imshow(cv.convertScaleAbs(I_y), cmap='gray')\nplt.axis('off')\nplt.title('Gradient in Y direction')\ncbar = plt.colorbar()\ncbar.set_label('Gradient Intensity')\n\nplt.subplot(2, 2, 3)\nplt.imshow(magnitude, cmap='gray')\nplt.axis('off')\nplt.title('Combined Gradient Magnitude')\ncbar = plt.colorbar()\ncbar.set_label('Gradient Intensity')\n\nplt.subplot(2, 2, 4)\nplt.imshow(direction)\nplt.axis('off')\nplt.title('Gradient Direction')\ncbar = plt.colorbar()\ncbar.set_label('Gradient Direction')\ncbar.set_ticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi])\ncbar.set_ticklabels(['-180°', '-90°', '0°', '90°', '180°'])\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n3. Non Maximum Suppression :\nThe algorithm then performs non-maximum suppression. The idea is to thin out the edges. We want to keep only the local maxima in the gradient direction. The algorithm goes through all the points on the gradient magnitude image and keeps only the points which are local maxima in the direction of the gradient. The pixel are checked in the direction of the gradient. If the pixel is not the maximum, it is set to zero.\nLet \\(M(x, y)\\) be defined as:\n\\[\n\\\nM(x, y) =\n\\begin{cases}\n0, & \\text{if } M(x, y) &lt; M(x + \\Delta x, y + \\Delta y) \\text{ or } M(x, y) &lt; M(x - \\Delta x, y - \\Delta y), \\\\\nM(x, y), & \\text{otherwise.}\n\\end{cases}\n\\\n\\]\nwhere \\(M(x,y)\\) is the gradient magnitude image and \\(\\Delta x\\) and \\(\\Delta y\\) are the unit vectors in the direction of the gradient.\n\n\n\n\nEdge Direction\n\n\nThe image on the left shows the gradient direction. The image on the right shows the process of non-maximum suppression. The point B (marked in Red) is the local maxima in the direction of the gradient while the points A and C (marked in black) are not. The points A and C are set to zero and the point B is kept. This operation will result in thinning of the edges.\n\nnms_image = np.zeros_like(magnitude)\n\n# Define the window size\nfor i in range(1, magnitude.shape[0] - 1):\n    for j in range(1, magnitude.shape[1] - 1):\n        # Define the angle interval\n        angle = direction[i, j] if direction[i, j] &gt;= 0 else direction[i, j] + np.pi\n        angle = np.rad2deg(angle)\n        angle = angle % 180\n\n        # Perform Non-Maximum Suppression\n        if (0 &lt;= angle &lt; 22.5) or (157.5 &lt;= angle &lt;= 180):\n            prev = magnitude[i, j - 1]\n            nxt = magnitude[i, j + 1]\n        elif 22.5 &lt;= angle &lt; 67.5:\n            prev = magnitude[i + 1, j - 1]\n            nxt = magnitude[i - 1, j + 1]\n        elif 67.5 &lt;= angle &lt; 112.5:\n            prev = magnitude[i - 1, j]\n            nxt = magnitude[i + 1, j]\n        else:\n            prev = magnitude[i - 1, j - 1]\n            nxt = magnitude[i + 1, j + 1]\n\n        if magnitude[i, j] &gt;= prev and magnitude[i, j] &gt;= nxt:\n            nms_image[i, j] = magnitude[i, j]\n\nplt.figure(figsize=(10, 4))\n\nplt.subplot(1, 2, 1)\nplt.imshow(magnitude, cmap='gray')\nplt.axis('off')\nplt.title('Gradient Magnitude')\ncbar = plt.colorbar()\ncbar.set_label('Gradient Intensity')\n\nplt.subplot(1, 2, 2)\nplt.imshow(nms_image, cmap='gray')\nplt.axis('off')\nplt.title('Non-Maximum Suppression')\ncbar = plt.colorbar()\ncbar.set_label('Gradient Intensity')\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n4. Hysteresis Thresholding:\nNext step is to apply hysteresis thresholding or also known as double thresholding. The algorithm uses two thresholds, a high threshold and a low threshold. All the points above the high threshold are considered to be strong edges and all the points below the low threshold are considered to be non-edges. The points between the two thresholds are considered to be weak edges. The algorithm then tracks the weak edges and checks if they are connected to strong edges. If they are connected to strong edges, they are considered to be edges. If they are not connected to strong edges, they are considered to be non-edges. This is done to remove the weak edges which are not connected to any of the strong edges.\nLet: - $ S $ denote the set of strong edges, - $ W $ denote the set of weak edges, - $ E(x, y) $ represent whether a pixel at ((x, y)) is classified as an edge ((1)) or not ((0)).\nThe classification can be expressed as:\n$$\nE(x, y) =\n\\[\\begin{cases}\n1, & \\text{if } (x, y) \\in S, \\text{ or } (x, y) \\in W \\text{ and connected to } S, \\\\\n0, & \\text{otherwise.}\n\\end{cases}\\]\n$$\nConnected to \\(S\\) implies there exists a path from \\((x, y)\\) in $ W $ to some \\((x', y')\\) in \\(S\\) that satisfies the connectivity criteria (e.g., adjacency).\n\nEdges = np.zeros_like(nms_image)\n\nthreshold_high = 100\nthreshold_low = 50\nvicinity = 2\n\n# Define the weak and strong edges\nstrong_edges = nms_image &gt; threshold_high\nweak_edges = (nms_image &gt;= threshold_low) & (nms_image &lt;= threshold_high)\n\n\n# Define the edge map\nEdges[strong_edges] = 255\n\n# Define the weak edges that are connected to strong edges\nfor i in range(1, nms_image.shape[0] - 1):\n    for j in range(1, nms_image.shape[1] - 1):\n        if weak_edges[i, j]:\n            if np.sum(strong_edges[i-vicinity:i+vicinity+1, j-vicinity:j+vicinity+1]) &gt; 0:\n                Edges[i, j] = 255\n\n# Dilate the edges\nEdges = cv.dilate(Edges, np.ones((3, 3), np.uint8), iterations=1)\n\n\n# Display the Original Image and the Detected Edges\nplt.figure(figsize=(7, 4))\n\nplt.subplot(1, 2, 1)\nplt.imshow(cv.cvtColor(image, cv.COLOR_BGR2RGB))\nplt.axis('off')\nplt.title('Original Image')\n\nplt.subplot(1, 2, 2)\nplt.imshow(Edges, cmap='gray')\nplt.axis('off')\nplt.title('Detected Edges')\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nThe Final output is the edge image where the edges are detected. The edges are detected using the gradient information. The algorithm is very effective in detecting edges and is widely used in computer vision applications."
  }
]